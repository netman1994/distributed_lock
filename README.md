### 库存扣减可能出现的问题
##### 错误案例一 数据库update互相覆盖
直接在内存中判断是否有库存，扣减之后更新数据库。高并发下可能导致互相覆盖发生
##### 错误案例二 扣减串行执行，但是库存被扣减为负数
在SQL中加入运算避免值的互相覆盖，但是库存的数量还是有可能扣为负数，因为校验库存是否足够还是在内存中执行的，并发情况下都会读到有库存
##### 错误案例三 使用synchronized实现内存中串行校验，但是依旧扣减为负数
使用@Transactional事务注解，synchronized加在方法上，方法执行结束的时候所就会释放，此时的事务还没有提交，另一个线程拿到锁之后就会又有一次扣减，导致负数。

### 解决办法
从上面造成的问题的原因来看，只要扣减库存（判断库存、扣减库存）的操作不是原子的。多线程同时操作就会有问题。

- 单体应用：使用本地锁+数据库中的行锁解决
- 分布式应用
  - 使用数据库中的乐观锁，加一个version字段，利用CAS来实现，会导致大量的update失败
  - 使用数据库维护一张锁表 + 悲观锁select，使用select for update实现
  - 使用redis的setNX实现分布式锁
  - 使用zookeeper的watcher + 有序临时节点来实现可阻塞的分布式锁
  - 使用Redisson框架内的分布式锁来实现
  - 使用curator框架内的分布式锁来实现



